# Language-Specific Bindings

This page covers how to consume the Factorial FFI from different
languages and runtimes. The C binding is fully supported and documented
below. Other language bindings are planned or community-contributed.

---

## C / C++

The `factorial-ffi` crate produces both a C header (`factorial.h`) and a
compiled library artifact. The header is generated automatically by
[cbindgen](https://github.com/mozilla/cbindgen) during `cargo build`.

### Generating the header

The header is regenerated every time the crate is built:

```bash
cargo build -p factorial-ffi
```

The output is written to `crates/factorial-ffi/factorial.h`. The
generation is driven by `cbindgen.toml`:

```toml
language = "C"
include_guard = "FACTORIAL_H"
autogen_warning = "/* Warning: this file is autogenerated by cbindgen. Do not modify. */"
no_includes = true
sys_includes = ["stdint.h", "stdbool.h", "stddef.h"]

[enum]
rename_variants = "ScreamingSnakeCase"

[export]
exclude = ["FactorialEngine"]
```

`FactorialEngine` is excluded from export because it is an opaque type.
The header declares it manually as a forward-declared struct:

```c
/* Opaque engine handle. */
typedef struct FactorialEngine FactorialEngine;
```

### Static linking

To statically link against the Factorial library from a C project,
build the crate in release mode and link the resulting archive:

```bash
# Build the library
cargo build -p factorial-ffi --release

# Compile and link (Linux)
gcc -o mygame main.c \
    -I crates/factorial-ffi \
    -L target/release \
    -l factorial_ffi \
    -l pthread -l dl -l m

# Compile and link (macOS)
gcc -o mygame main.c \
    -I crates/factorial-ffi \
    -L target/release \
    -l factorial_ffi \
    -framework Security -framework CoreFoundation
```

The `-I` flag adds the header search path so that `#include "factorial.h"`
resolves. The `-L` flag adds the library search path. The `-l` flag
links the static archive (`libfactorial_ffi.a`).

On Linux, you must also link the system libraries that Rust depends on:
`pthread`, `dl`, and `m`. On macOS, the Security and CoreFoundation
frameworks may be required depending on your Rust dependencies.

### Dynamic linking

The crate is configured with `crate-type = ["cdylib", "rlib"]`, so
`cargo build` also produces a shared library:

| Platform | File                          | Extension |
|----------|-------------------------------|-----------|
| Linux    | `libfactorial_ffi.so`         | `.so`     |
| macOS    | `libfactorial_ffi.dylib`      | `.dylib`  |
| Windows  | `factorial_ffi.dll`           | `.dll`    |

To link dynamically:

```bash
# Linux
gcc -o mygame main.c \
    -I crates/factorial-ffi \
    -L target/release \
    -l factorial_ffi

# Set the runtime library path
export LD_LIBRARY_PATH=target/release:$LD_LIBRARY_PATH
./mygame

# macOS
gcc -o mygame main.c \
    -I crates/factorial-ffi \
    -L target/release \
    -l factorial_ffi

export DYLD_LIBRARY_PATH=target/release:$DYLD_LIBRARY_PATH
./mygame
```

On Windows with MSVC:

```bat
cl main.c /I crates\factorial-ffi /link target\release\factorial_ffi.dll.lib
```

Ensure the `.dll` (or `.so` / `.dylib`) is in the executable's search
path at runtime.

### Minimal C example

```c
#include "factorial.h"
#include <stdio.h>

int main(void) {
    FactorialEngine *engine = factorial_create();
    if (!engine) {
        fprintf(stderr, "Failed to create engine\n");
        return 1;
    }

    /* Add a node */
    FfiPendingNodeId pending;
    factorial_add_node(engine, 0, &pending);

    /* Apply mutations */
    FfiMutationResult mutations;
    factorial_apply_mutations(engine, &mutations);
    printf("Added %u node(s)\n", mutations.added_node_count);

    /* Step the simulation */
    factorial_step(engine);

    /* Query tick */
    uint64_t tick;
    factorial_get_tick(engine, &tick);
    printf("Tick: %llu\n", (unsigned long long)tick);

    /* Clean up */
    factorial_destroy(engine);
    return 0;
}
```

### C++ notes

The generated header is pure C. To use it from C++, wrap the include in
an `extern "C"` block:

```cpp
extern "C" {
#include "factorial.h"
}
```

Alternatively, if building with a C++ compiler, define a wrapper header
that adds the linkage specification.

---

## C# / Unity (P/Invoke)

> **Status: planned.** Community contributions welcome.

The C FFI is directly consumable from C# via P/Invoke. A future
`Factorial.Interop` NuGet package or Unity plugin will provide:

- A managed wrapper with `[DllImport("factorial_ffi")]` declarations
  for every function in the [Function Reference](reference.md).
- Automatic marshalling of `FfiNodeId`, `FfiEdgeId`, and result codes
  into C# enums and structs.
- An `IDisposable` wrapper around `FactorialEngine*` to ensure
  `factorial_destroy()` is called on garbage collection.
- Unity Editor integration for the shared library (.dll on Windows,
  .bundle on macOS, .so on Linux).

In the meantime, you can write P/Invoke declarations manually:

```csharp
// Example (untested sketch)
[DllImport("factorial_ffi")]
private static extern IntPtr factorial_create();

[DllImport("factorial_ffi")]
private static extern FactorialResult factorial_step(IntPtr engine);

[DllImport("factorial_ffi")]
private static extern FactorialResult factorial_destroy(IntPtr engine);
```

Place the compiled shared library in your Unity project's
`Assets/Plugins` directory, matching the target platform.

---

## GDScript / Godot (GDExtension)

> **Status: planned.** Community contributions welcome.

Godot 4.x supports native extensions via
[GDExtension](https://docs.godotengine.org/en/stable/tutorials/scripting/gdextension/index.html).
A future `factorial-gdextension` crate will provide:

- A GDExtension wrapper that registers Factorial types as Godot classes.
- A `FactorialEngine` node that can be added to the scene tree.
- Signal-based event delivery (bridging the pull-based FFI event model
  to Godot signals).
- Export of node/edge IDs as Godot `int` values.

Until then, you can load the shared library directly using GDExtension's
C API, or use the C FFI through Godot's `GDNative` (Godot 3.x) or
`NativeScript` interfaces.

---

## Python (ctypes / PyO3)

> **Status: planned.** Community contributions welcome.

Two integration paths are available:

### ctypes (no compilation required)

Python's built-in `ctypes` module can load the shared library directly:

```python
# Example (untested sketch)
import ctypes

lib = ctypes.CDLL("./libfactorial_ffi.so")  # or .dylib / .dll

lib.factorial_create.restype = ctypes.c_void_p
lib.factorial_step.argtypes = [ctypes.c_void_p]
lib.factorial_step.restype = ctypes.c_int

engine = lib.factorial_create()
lib.factorial_step(engine)
lib.factorial_destroy(engine)
```

### PyO3 (native Python module)

A future `factorial-python` crate built with
[PyO3](https://pyo3.rs/) and [maturin](https://www.maturin.rs/) will
provide a native Python module with:

- Pythonic class wrappers (`Engine`, `NodeId`, `EdgeId`).
- Automatic resource management via `__enter__` / `__exit__`.
- Event iteration via Python iterators.
- Type stubs for IDE autocompletion.

---

## Other languages

Any language that supports calling C functions can use the Factorial FFI.
The general approach is:

1. Build the `factorial-ffi` crate to produce a shared library.
2. Load the shared library using your language's FFI mechanism.
3. Declare the function signatures from the
   [Function Reference](reference.md).
4. Follow the [API Conventions & Safety](conventions.md) rules.

If you create bindings for a language not listed here, consider
contributing them back to the project.

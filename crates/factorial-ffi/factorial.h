#ifndef FACTORIAL_H
#define FACTORIAL_H

/* Warning: this file is autogenerated by cbindgen. Do not modify. */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
/* Opaque engine handle. */
typedef struct FactorialEngine FactorialEngine;


/**
 * Status codes returned by all FFI functions.
 */
typedef enum FactorialResult {
  /**
   * Success.
   */
  OK = 0,
  /**
   * A required pointer argument was null.
   */
  NULL_POINTER = 1,
  /**
   * The engine handle is invalid (null or dangling).
   */
  INVALID_HANDLE = 2,
  /**
   * Serialization failed.
   */
  SERIALIZE_ERROR = 3,
  /**
   * Deserialization failed.
   */
  DESERIALIZE_ERROR = 4,
  /**
   * The requested node was not found.
   */
  NODE_NOT_FOUND = 5,
  /**
   * The requested edge was not found.
   */
  EDGE_NOT_FOUND = 6,
  /**
   * An internal panic was caught at the FFI boundary.
   */
  INTERNAL_ERROR = 7,
  /**
   * The engine is poisoned (a previous panic left it in an inconsistent state).
   */
  POISONED = 8,
} FactorialResult;

/**
 * C-compatible processor state tag.
 */
typedef enum FfiProcessorState {
  IDLE = 0,
  WORKING = 1,
  STALLED_MISSING_INPUTS = 2,
  STALLED_OUTPUT_FULL = 3,
  STALLED_NO_POWER = 4,
  STALLED_DEPLETED = 5,
} FfiProcessorState;

/**
 * C-compatible event tag.
 */
typedef enum FfiEventKind {
  ITEM_PRODUCED = 0,
  ITEM_CONSUMED = 1,
  RECIPE_STARTED = 2,
  RECIPE_COMPLETED = 3,
  BUILDING_STALLED = 4,
  BUILDING_RESUMED = 5,
  ITEM_DELIVERED = 6,
  TRANSPORT_FULL = 7,
  NODE_ADDED = 8,
  NODE_REMOVED = 9,
  EDGE_ADDED = 10,
  EDGE_REMOVED = 11,
  RECIPE_SWITCHED = 12,
} FfiEventKind;

/**
 * C-compatible wire color.
 */
typedef enum FfiWireColor {
  RED = 0,
  GREEN = 1,
} FfiWireColor;

/**
 * C-compatible signal selector kind.
 */
typedef enum FfiSelectorKind {
  SIGNAL = 0,
  CONSTANT = 1,
  EACH = 2,
} FfiSelectorKind;

/**
 * C-compatible arithmetic operation.
 */
typedef enum FfiArithmeticOp {
  ADD = 0,
  SUB = 1,
  MUL = 2,
  DIV = 3,
  MOD = 4,
} FfiArithmeticOp;

/**
 * C-compatible comparison operation.
 */
typedef enum FfiComparisonOp {
  GT = 0,
  LT = 1,
  EQ = 2,
  GTE = 3,
  LTE = 4,
  NE = 5,
} FfiComparisonOp;

/**
 * C-compatible decider output kind.
 */
typedef enum FfiDeciderOutputKind {
  ONE = 0,
  INPUT_COUNT = 1,
  EVERYTHING = 2,
} FfiDeciderOutputKind;

/**
 * C-compatible representation of a PendingNodeId.
 */
typedef uint64_t FfiPendingNodeId;

/**
 * C-compatible representation of a NodeId (u64 ffi key).
 */
typedef uint64_t FfiNodeId;

/**
 * C-compatible representation of a PendingEdgeId.
 */
typedef uint64_t FfiPendingEdgeId;

/**
 * C-compatible representation of an EdgeId (u64 ffi key).
 */
typedef uint64_t FfiEdgeId;

/**
 * A pair of (pending_id, real_id) for mutation results.
 */
typedef struct FfiIdPair {
  uint64_t pending_id;
  uint64_t real_id;
} FfiIdPair;

/**
 * Result of applying mutations. Maps pending IDs to real IDs.
 */
typedef struct FfiMutationResult {
  /**
   * Array of (pending_node_id, real_node_id) pairs.
   */
  const struct FfiIdPair *added_nodes;
  uint32_t added_node_count;
  /**
   * Array of (pending_edge_id, real_edge_id) pairs.
   */
  const struct FfiIdPair *added_edges;
  uint32_t added_edge_count;
} FfiMutationResult;

/**
 * C-compatible processor state with progress.
 */
typedef struct FfiProcessorInfo {
  enum FfiProcessorState state;
  /**
   * For `Working` state, the current progress tick. 0 otherwise.
   */
  uint32_t progress;
} FfiProcessorInfo;

/**
 * C-compatible event data. Union fields are determined by `kind`.
 * We use a flat struct with all possible fields to keep it simple and
 * fully `repr(C)` without actual C unions.
 */
typedef struct FfiEvent {
  enum FfiEventKind kind;
  uint64_t tick;
  /**
   * Node ID (used by most events). 0 if not applicable.
   */
  FfiNodeId node;
  /**
   * Edge ID (used by transport events). 0 if not applicable.
   */
  FfiEdgeId edge;
  /**
   * Item type ID (used by item events). 0 if not applicable.
   */
  uint32_t item_type;
  /**
   * Quantity (used by item events). 0 if not applicable.
   */
  uint32_t quantity;
  /**
   * Building type ID (used by NodeAdded). 0 if not applicable.
   */
  uint32_t building_type;
  /**
   * Source node (used by EdgeAdded). 0 if not applicable.
   */
  FfiNodeId from_node;
  /**
   * Dest node (used by EdgeAdded). 0 if not applicable.
   */
  FfiNodeId to_node;
} FfiEvent;

/**
 * Result of polling events: a pointer to engine-owned event buffer and count.
 */
typedef struct FfiEventBuffer {
  /**
   * Pointer to an array of `FfiEvent`. Valid until next step/destroy.
   */
  const struct FfiEvent *events;
  /**
   * Number of events in the buffer.
   */
  uint32_t count;
} FfiEventBuffer;

/**
 * An engine-allocated byte buffer returned from serialization.
 */
typedef struct FfiByteBuffer {
  /**
   * Pointer to the data. Null on error.
   */
  uint8_t *data;
  /**
   * Length in bytes.
   */
  uintptr_t len;
} FfiByteBuffer;

/**
 * C-compatible item stack (item type + quantity).
 */
typedef struct FfiItemStack {
  uint32_t item_type;
  uint32_t quantity;
} FfiItemStack;

/**
 * C-compatible recipe for FixedRecipe processor.
 */
typedef struct FfiRecipe {
  uint32_t input_count;
  const struct FfiItemStack *inputs;
  uint32_t output_count;
  const struct FfiItemStack *outputs;
  uint32_t duration;
} FfiRecipe;

/**
 * C-compatible wire network ID.
 */
typedef uint32_t FfiWireNetworkId;

/**
 * Create a new engine with `Tick` simulation strategy.
 * Returns a heap-allocated engine pointer. The caller must eventually
 * call `factorial_destroy` to free the memory.
 *
 * Returns null on internal error.
 */
FactorialEngine *factorial_create(void);

/**
 * Create a new engine with `Delta` simulation strategy.
 * `fixed_timestep` is the number of ticks per fixed simulation step.
 *
 * Returns null on internal error.
 */
FactorialEngine *factorial_create_delta(uint64_t fixed_timestep);

/**
 * Destroy an engine and free its memory.
 *
 * # Safety
 *
 * `engine` must be a pointer returned by `factorial_create` that has not
 * yet been destroyed. After this call the pointer is invalid.
 */
enum FactorialResult factorial_destroy(FactorialEngine *engine);

/**
 * Advance the simulation by one tick (tick mode) or by `dt` ticks (delta mode).
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_step(FactorialEngine *engine);

/**
 * Advance the simulation by `dt` ticks. In tick mode `dt` is ignored
 * and exactly one step runs. In delta mode, `dt` is accumulated.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_advance(FactorialEngine *engine, uint64_t dt);

/**
 * Queue a node to be added to the graph. Returns a pending node ID
 * via `out_pending`. The real node ID is assigned after `factorial_apply_mutations`.
 *
 * # Safety
 *
 * `engine` and `out_pending` must be valid pointers.
 */
enum FactorialResult factorial_add_node(FactorialEngine *engine,
                                        uint32_t building_type,
                                        FfiPendingNodeId *out_pending);

/**
 * Queue a node for removal.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_remove_node(FactorialEngine *engine, FfiNodeId node_id);

/**
 * Queue an edge connecting two nodes. Returns a pending edge ID via `out_pending`.
 *
 * # Safety
 *
 * `engine` and `out_pending` must be valid pointers.
 */
enum FactorialResult factorial_connect(FactorialEngine *engine,
                                       FfiNodeId from_node,
                                       FfiNodeId to_node,
                                       FfiPendingEdgeId *out_pending);

/**
 * Queue an edge for removal (disconnect).
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_disconnect(FactorialEngine *engine, FfiEdgeId edge_id);

/**
 * Apply all queued graph mutations atomically. Results (pending->real ID
 * mappings) are written to `out_result`.
 *
 * # Safety
 *
 * `engine` and `out_result` must be valid pointers. The pointers in the
 * returned `FfiMutationResult` are valid until the next call to
 * `factorial_apply_mutations` or `factorial_destroy`.
 */
enum FactorialResult factorial_apply_mutations(FactorialEngine *engine,
                                               struct FfiMutationResult *out_result);

/**
 * Get the number of nodes in the graph.
 *
 * # Safety
 *
 * `engine` and `out_count` must be valid pointers.
 */
enum FactorialResult factorial_node_count(const FactorialEngine *engine, uint32_t *out_count);

/**
 * Get the number of edges in the graph.
 *
 * # Safety
 *
 * `engine` and `out_count` must be valid pointers.
 */
enum FactorialResult factorial_edge_count(const FactorialEngine *engine, uint32_t *out_count);

/**
 * Get the current tick counter.
 *
 * # Safety
 *
 * `engine` and `out_tick` must be valid pointers.
 */
enum FactorialResult factorial_get_tick(const FactorialEngine *engine, uint64_t *out_tick);

/**
 * Get the state hash of the engine (for desync detection).
 *
 * # Safety
 *
 * `engine` and `out_hash` must be valid pointers.
 */
enum FactorialResult factorial_get_state_hash(const FactorialEngine *engine, uint64_t *out_hash);

/**
 * Get the processor state for a node.
 *
 * # Safety
 *
 * `engine` and `out_info` must be valid pointers.
 */
enum FactorialResult factorial_get_processor_state(const FactorialEngine *engine,
                                                   FfiNodeId node_id,
                                                   struct FfiProcessorInfo *out_info);

/**
 * Get the total item count in a node's input inventory.
 *
 * # Safety
 *
 * `engine` and `out_count` must be valid pointers.
 */
enum FactorialResult factorial_get_input_inventory_count(const FactorialEngine *engine,
                                                         FfiNodeId node_id,
                                                         uint32_t *out_count);

/**
 * Get the total item count in a node's output inventory.
 *
 * # Safety
 *
 * `engine` and `out_count` must be valid pointers.
 */
enum FactorialResult factorial_get_output_inventory_count(const FactorialEngine *engine,
                                                          FfiNodeId node_id,
                                                          uint32_t *out_count);

/**
 * Poll all buffered events since the last step. Returns a pointer to an
 * engine-owned buffer of `FfiEvent` structs. The buffer is valid until the
 * next `factorial_step`, `factorial_advance`, or `factorial_destroy`.
 *
 * # Safety
 *
 * `engine` and `out_buffer` must be valid pointers.
 */
enum FactorialResult factorial_poll_events(const FactorialEngine *engine,
                                           struct FfiEventBuffer *out_buffer);

/**
 * Serialize the engine state to a binary buffer. The returned
 * `FfiByteBuffer` contains a pointer and length. The caller must free the
 * buffer with `factorial_free_buffer` when done.
 *
 * # Safety
 *
 * `engine` and `out_buffer` must be valid pointers.
 */
enum FactorialResult factorial_serialize(const FactorialEngine *engine,
                                         struct FfiByteBuffer *out_buffer);

/**
 * Deserialize an engine from a binary buffer. Returns a new engine pointer
 * via `out_engine`. The caller takes ownership.
 *
 * # Safety
 *
 * `data` must point to `len` valid bytes. `out_engine` must be a valid pointer.
 */
enum FactorialResult factorial_deserialize(const uint8_t *data,
                                           uintptr_t len,
                                           FactorialEngine **out_engine);

/**
 * Free a byte buffer returned by `factorial_serialize`.
 *
 * # Safety
 *
 * `buffer` must be a buffer originally returned by `factorial_serialize`.
 * After this call the buffer's data pointer is invalid.
 */
enum FactorialResult factorial_free_buffer(struct FfiByteBuffer buffer);

/**
 * Set a node's processor to Source.
 *
 * `rate` is raw Fixed64 bits (Q32.32). Use `Fixed64::to_bits()` on the Rust
 * side or shift an integer left by 32 on the C side to construct it.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_set_source(FactorialEngine *engine,
                                          FfiNodeId node_id,
                                          uint32_t item_type,
                                          int64_t rate);

/**
 * Set a node's processor to FixedRecipe.
 *
 * The `recipe` pointer must point to a valid `FfiRecipe` whose `inputs` and
 * `outputs` arrays have the declared counts.
 *
 * # Safety
 *
 * `engine` and `recipe` must be valid pointers. The arrays referenced by
 * `recipe.inputs` and `recipe.outputs` must be valid for the declared counts.
 */
enum FactorialResult factorial_set_fixed_processor(FactorialEngine *engine,
                                                   FfiNodeId node_id,
                                                   const struct FfiRecipe *recipe);

/**
 * Set an edge's transport to FlowTransport with default buffer/latency.
 *
 * `rate` is raw Fixed64 bits (Q32.32).
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_set_flow_transport(FactorialEngine *engine,
                                                  FfiEdgeId edge_id,
                                                  int64_t rate);

/**
 * Set an edge's transport to ItemTransport.
 *
 * `speed` is raw Fixed64 bits (Q32.32).
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_set_item_transport(FactorialEngine *engine,
                                                  FfiEdgeId edge_id,
                                                  int64_t speed,
                                                  uint32_t slot_count,
                                                  uint8_t lanes);

/**
 * Set an edge's transport to BatchTransport.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_set_batch_transport(FactorialEngine *engine,
                                                   FfiEdgeId edge_id,
                                                   uint32_t batch_size,
                                                   uint32_t cycle_time);

/**
 * Set an edge's transport to VehicleTransport.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_set_vehicle_transport(FactorialEngine *engine,
                                                     FfiEdgeId edge_id,
                                                     uint32_t capacity,
                                                     uint32_t travel_time);

/**
 * Set the input inventory for a node with the given capacity.
 *
 * Creates an inventory with 1 input slot and 1 output slot.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_set_input_capacity(FactorialEngine *engine,
                                                  FfiNodeId node_id,
                                                  uint32_t capacity);

/**
 * Set the output inventory for a node with the given capacity.
 *
 * Creates an inventory with 1 input slot and 1 output slot.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_set_output_capacity(FactorialEngine *engine,
                                                   FfiNodeId node_id,
                                                   uint32_t capacity);

/**
 * Check whether the engine is poisoned (a previous panic left it in an
 * inconsistent state). Returns `false` if the engine pointer is null.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer or null.
 */
bool factorial_is_poisoned(const FactorialEngine *engine);

/**
 * Clear the poisoned flag on an engine, allowing it to be used again.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_clear_poison(FactorialEngine *engine);

/**
 * Register the logic module with the engine.
 *
 * Must be called before any other `factorial_logic_*` function. Calling
 * this more than once on the same engine is a no-op (the second bridge
 * is simply added; prefer calling only once).
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_logic_register(FactorialEngine *engine);

/**
 * Create a wire network with the given color. The new network ID is
 * written to `out_id`.
 *
 * # Safety
 *
 * `engine` and `out_id` must be valid pointers.
 */
enum FactorialResult factorial_logic_create_network(FactorialEngine *engine,
                                                    enum FfiWireColor color,
                                                    FfiWireNetworkId *out_id);

/**
 * Remove a wire network.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_logic_remove_network(FactorialEngine *engine,
                                                    FfiWireNetworkId network_id);

/**
 * Add a node to a wire network.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_logic_add_to_network(FactorialEngine *engine,
                                                    FfiWireNetworkId network_id,
                                                    FfiNodeId node_id);

/**
 * Remove a node from a wire network.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_logic_remove_from_network(FactorialEngine *engine,
                                                         FfiWireNetworkId network_id,
                                                         FfiNodeId node_id);

/**
 * Set a constant combinator on a node.
 *
 * `item_ids_ptr` and `values_ptr` are parallel arrays of length `count`.
 * Each pair defines a signal: `item_ids[i]` -> `values[i]` (raw Fixed64 bits).
 * `enabled` is non-zero for enabled.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer. `item_ids_ptr` and `values_ptr`
 * must point to arrays of at least `count` elements.
 */
enum FactorialResult factorial_logic_set_constant(FactorialEngine *engine,
                                                  FfiNodeId node_id,
                                                  const uint32_t *item_ids_ptr,
                                                  const int64_t *values_ptr,
                                                  uint32_t count,
                                                  uint8_t enabled);

/**
 * Set an arithmetic combinator on a node.
 *
 * Left/right operands are specified as (kind, value) pairs where `value`
 * is the item ID for `Signal`, raw Fixed64 bits for `Constant`, or
 * ignored for `Each`.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_logic_set_arithmetic(FactorialEngine *engine,
                                                    FfiNodeId node_id,
                                                    enum FfiSelectorKind left_kind,
                                                    uint64_t left_value,
                                                    enum FfiArithmeticOp op,
                                                    enum FfiSelectorKind right_kind,
                                                    uint64_t right_value,
                                                    uint32_t output_item);

/**
 * Set a decider combinator on a node.
 *
 * Left/right operands are specified as (kind, value) pairs. The output
 * kind determines what is emitted when the condition is true.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_logic_set_decider(FactorialEngine *engine,
                                                 FfiNodeId node_id,
                                                 enum FfiSelectorKind left_kind,
                                                 uint64_t left_value,
                                                 enum FfiComparisonOp cmp_op,
                                                 enum FfiSelectorKind right_kind,
                                                 uint64_t right_value,
                                                 enum FfiDeciderOutputKind output_kind,
                                                 uint32_t output_item);

/**
 * Set circuit control on a node.
 *
 * The condition is specified as left/right (kind, value) pairs and a
 * comparison operator. The wire color determines which network to read
 * signals from.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_logic_set_circuit_control(FactorialEngine *engine,
                                                         FfiNodeId node_id,
                                                         enum FfiSelectorKind left_kind,
                                                         uint64_t left_value,
                                                         enum FfiComparisonOp cmp_op,
                                                         enum FfiSelectorKind right_kind,
                                                         uint64_t right_value,
                                                         enum FfiWireColor wire_color);

/**
 * Query whether a node's circuit control condition is active.
 *
 * Writes `1` to `out_active` if active, `0` if inactive. Returns
 * `NodeNotFound` if the node has no circuit control.
 *
 * # Safety
 *
 * `engine` and `out_active` must be valid pointers.
 */
enum FactorialResult factorial_logic_is_active(FactorialEngine *engine,
                                               FfiNodeId node_id,
                                               uint8_t *out_active);

/**
 * Query a signal value from a wire network.
 *
 * Writes the raw Fixed64 bits to `out_value`. If the signal is not
 * present, writes 0.
 *
 * # Safety
 *
 * `engine` and `out_value` must be valid pointers.
 */
enum FactorialResult factorial_logic_get_network_signal(FactorialEngine *engine,
                                                        FfiWireNetworkId network_id,
                                                        uint32_t item_id,
                                                        int64_t *out_value);

/**
 * Remove all logic state for a node (constant, combinators, circuit
 * control, and network memberships).
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_logic_remove_node(FactorialEngine *engine, FfiNodeId node_id);

/**
 * Set an inventory reader on a node. The reader watches `target_node_id`
 * and emits signals based on its inventory contents.
 *
 * `source` is `0` for Input, `1` for Output.
 *
 * # Safety
 *
 * `engine` must be a valid engine pointer.
 */
enum FactorialResult factorial_logic_set_inventory_reader(FactorialEngine *engine,
                                                          FfiNodeId node_id,
                                                          FfiNodeId target_node_id,
                                                          uint8_t source);

#endif  /* FACTORIAL_H */
